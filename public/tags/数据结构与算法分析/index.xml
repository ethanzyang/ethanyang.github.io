<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构与算法分析 on Jerrkill - 为学日益为道日损</title>
    <link>http://example.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link>
    <description>Recent content in 数据结构与算法分析 on Jerrkill - 为学日益为道日损</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 21 Feb 2019 00:35:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优先队列 二叉堆【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/priority-queue-binary-heap-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Thu, 21 Feb 2019 00:35:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/priority-queue-binary-heap-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>前言 有段时间没看算法跟数据结构了，今天看了『优先队列』,并写成笔记。 概念 为什么需要优先队列? 在一个队列中的作业，有的时候我们需要优先处理某些</description>
    </item>
    
    <item>
      <title>散列表 ADT 开放地址法解决冲突【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/hash-table-adt-open-address-method-to-resolve-conflicts-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Fri, 25 Jan 2019 11:51:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/hash-table-adt-open-address-method-to-resolve-conflicts-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 前言 前一节用分离链接法解决了冲突问题，同时该算法也具有自己的缺点。 需要指针，新单元分配地址需要时间，导致速度减慢。 需要实现另一种数据结构（</description>
    </item>
    
    <item>
      <title>伸展树【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/splay-tree-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Mon, 14 Jan 2019 18:59:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/splay-tree-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 概述 知识点 伸展树的由来 伸展树的概念 伸展树的展开 2. 伸展树的想法由来 二叉搜索树的最坏情况是一个单链表，复杂度为 O(N)。如果发生最坏的情况很少</description>
    </item>
    
    <item>
      <title>AVL 树【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/avl-tree-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Sun, 13 Jan 2019 03:11:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/avl-tree-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 概述 主要知识点 AVL 树定义 单旋转（左左单旋转、右右单旋转） 双旋转（左右双旋转、右左双旋转） 2. 什么是 AVL 树 定义 带有平衡条件的二叉查找树。 平衡条件：</description>
    </item>
    
    <item>
      <title>二叉树 &amp; 二叉查找树 ADT【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/binary-tree--binary-search-tree-adt-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Fri, 28 Dec 2018 23:53:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/binary-tree--binary-search-tree-adt-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 引言 主要涉及知识点 二叉树的概念。 二叉查找树的概念跟常用操作。 二叉树的遍历（先序遍历、中序遍历、后序遍历、层序遍历）。 其他 队列（层序遍历用到</description>
    </item>
    
    <item>
      <title>树【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/tree-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Fri, 28 Dec 2018 00:27:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/tree-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 树的概念 树就是一种非线性的数据结构，其平均复杂度为O(logN)。 2. 实现思路 只需要一个指向第一个节点的指针跟右侧兄弟节点的指针 3. 实现过程 定</description>
    </item>
    
    <item>
      <title>栈的应用之平衡符号 【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/the-balance-symbol-of-the-application-of-the-stack-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Wed, 26 Dec 2018 18:38:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/the-balance-symbol-of-the-application-of-the-stack-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>描述 实现思路 读入文件挨个字符遍历直到 \0 识别字符。 遇到 { [ ( 入栈。 遇到 } ] ) ，对比栈顶元素，是否成对，是就弹出，否就报错，栈顶为空也报错。 遍历</description>
    </item>
    
    <item>
      <title>队列 ADT 【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/queue-adt-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Wed, 26 Dec 2018 00:42:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/queue-adt-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 队列模型 2. 队列数组实现 数组实现在创建时候需要比链表多传入一个 max_size ,即需要指定数组的长度。 数组存放队列内容，size - 队列长度， front - 队头，re</description>
    </item>
    
    <item>
      <title>栈 ADT [数据结构与算法分析 c 语言描述]</title>
      <link>http://example.org/post/dev/stack-adt-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Mon, 24 Dec 2018 19:07:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/stack-adt-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>栈模型 后进先出表 栈实现 需要实现 创建空栈 置空栈 入栈 出栈 获取栈顶 销毁栈 链表实现 结构体存放栈元素跟指向栈下一个结构体的指针 入栈 一个新的节点添加到 header-&amp;gt;next,</description>
    </item>
    
    <item>
      <title>基数排序-单链表实现 [数据结构与算法分析（c 语言描述）]</title>
      <link>http://example.org/post/dev/cardinality-sorting---singly-linked-list-implementation-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Sun, 23 Dec 2018 22:37:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/cardinality-sorting---singly-linked-list-implementation-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>实现思路 基数排序本身是一个：分配-收集 过程 将一组需要排序的数，用链表存储 记为 L 用一组链表的来存放分配的节点 N[0-9] 遍历 L 每个节点分配到对应的 N[0-9] 将 N[0-9]</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）多项式 ADT 单链表实现</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-radix-sorting-array-implementation/</link>
      <pubDate>Thu, 20 Dec 2018 22:13:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-radix-sorting-array-implementation/</guid>
      <description>/** * 基数排序数组实现 * 思路: * 基数排序是一个 分配-收集 的过程 * N--需要排序的个数 radix-基数 pos_len 位数 * 其中用二维数组来表示桶[j][N]</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）多项式 ADT 单链表实现</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-implementation-of-polynomial-adt-singly-linked-list/</link>
      <pubDate>Wed, 19 Dec 2018 22:06:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-implementation-of-polynomial-adt-singly-linked-list/</guid>
      <description>/** * 多项式-单链表实现 * 思路： * 加法思路：P1(n~0) P2(i~0),假设n&amp;gt;i的(方便描述),P1(n)跟P2(n)比较关系,把大</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）多项式 ADT 数组实现</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-polynomial-adt-array-implementation/</link>
      <pubDate>Wed, 19 Dec 2018 21:51:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-polynomial-adt-array-implementation/</guid>
      <description>/** * 多项式 ADT 数组实现 * 思路：以数组的 key 作为多项式的次数, value 作为多项式的系数。Hightpower 作为多项式的最高次数 */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define MaxDegree 50</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）最大子序列和问题</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-maximum-subsequence-sum-problem/</link>
      <pubDate>Fri, 14 Dec 2018 23:45:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-maximum-subsequence-sum-problem/</guid>
      <description>ps：我怕我发的会打扰到大家，本意只是想记下学习研究过程跟结果，这些很基础的东西，如果打扰到大家的话在底下说下，以后就不发这种了 /** * 给定(可</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）习题 1.3</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.3/</link>
      <pubDate>Fri, 14 Dec 2018 22:08:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.3/</guid>
      <description>/** * 1.3 * 只使用处理I/O的PrintDigit函数，编写一个过程以输出任意实数 * */ #include &amp;lt;stdio.h&amp;gt; #define PrintDigit( Ch ) ( putchar( ( Ch ) + &amp;#39;0&amp;#39; ) ) void print_int(int N); void print_out(double N, int j); int main(void) { // double a,</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）习题 1.2</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.2/</link>
      <pubDate>Fri, 14 Dec 2018 22:04:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.2/</guid>
      <description>/** * 编写一个程序求解字谜游戏问题。 * * 描述：输入是由一些字母和单词构成的二维数组，目标是找出字谜中的单词，这些单词可以是水平、垂直或沿对角线</description>
    </item>
    
    <item>
      <title>数据结构与算法分析（c 语言描述）习题 1.1</title>
      <link>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.1/</link>
      <pubDate>Wed, 12 Dec 2018 15:56:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/data-structure-and-algorithm-analysis-c-language-description-exercises-1.1/</guid>
      <description>/** * 问题描述：编写一个程序解决选择问题。令k = N / 2。画出表格显示你的程序对于N为不同值时的运行时间。 *（设有一组 N 个数确定其中第 k 个最大者</description>
    </item>
    
    <item>
      <title>散列表 ADT 分离链接法【数据结构与算法分析 c 语言描述】</title>
      <link>http://example.org/post/dev/hash-table-adt-separate-chaining-method-data-structure-and-algorithm-analysis-c-language/</link>
      <pubDate>Sun, 23 Jan 2011 18:04:00 +0000</pubDate>
      
      <guid>http://example.org/post/dev/hash-table-adt-separate-chaining-method-data-structure-and-algorithm-analysis-c-language/</guid>
      <description>1. 前言 前面看了 链表 ADT 栈 ADT 队列 ADT 树 ADT 各自 ADT 都有自己特有的优势跟劣势以及应用场景，散列表也不例外。 散列表 常数平均时间执行插入、查找、删除操作。不</description>
    </item>
    
  </channel>
</rss>
